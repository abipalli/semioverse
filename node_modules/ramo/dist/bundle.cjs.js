'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const empty = null;

const cons = (head, tail) => ({ head, tail });

const unit = v => cons(v, empty);

const concat = (s1, s2) => {
  if (s1 === empty) return s2;
  else if (typeof s1 === 'function') return () => concat(s2, s1());
  else return cons(s1.head, concat(s1.tail, s2));
};

const chain = (f, s) => {
  if (s === empty) return empty;
  else if (typeof s === 'function') return () => chain(f, s());
  else return concat(f(s.head), chain(f, s.tail));
};

const take = (n, s) => {
  const result = [];
  while (n !== 0 && s !== empty) {
    if (typeof s === 'function') s = s();
    else {
      result.push(s.head);
      s = s.tail;
      if (n !== false) --n;
    }
  }
  return result;
};

// Terms
const isComp = x => x && typeof x === 'object' && !isVar(x);

const VAR = Symbol('ramo.VAR');
const Var = () => ({ [VAR]: true });
const isVar = x => x && typeof x === 'object' && VAR in x;

// Substitutions
const walk = (x, s) => s.has(x) ? walk(s.get(x), s) : x;

const walkAll = (x, s) => {
  x = walk(x, s);
  if (isComp(x)) {
    const x1 = Object.create(Object.getPrototypeOf(x));
    for (let k of keysIn(x)) {
      x1[k] = walkAll(x[k], s);
    }
    return x1;
  }
  return x;
};

// Tools
const keysIn = x =>
  [...Object.keys(x), ...Object.getOwnPropertySymbols(x)];

const iota = n => [...Array(n).keys()];

const toArray = x => Array.isArray(x) ? x : [x];

const reify = (x, s) => {
  x = walkAll(x, s);
  return walkAll(x, reifyS(x, new Map()));
};

const reifyS = (x, r) => {
  x = walk(x, r);
  if (isVar(x)) return reifyVar(x, r);
  else if (isComp(x)) return reifyComp(x, r);
  else return r;
};

const reifyVar = (v, r) => new Map(r).set(v, `_${r.size}`);

const reifyComp = (x, r) => keysIn(x).reduce((r, k) => reifyS(x[k], r), r);

const NIL = Symbol('ramo.NIL');
const FIRST = Symbol('ramo.FIRST');
const REST = Symbol('ramo.REST');
const WILD = Symbol('ramo.WILD');

const cons$1 = (first, rest) => ({ [FIRST]: first, [REST]: rest });
const first = p => p[FIRST];
const rest = p => p[REST];

const unsweeten = x => {
  if (x === WILD) return Var();
  else if (Array.isArray(x)) return unsweetenArray(x);
  else if (isComp(x)) return unsweetenComp(x);
  else return x;
};

const unsweetenArray = xs =>
  xs.length === 0
  ? NIL
  : cons$1(unsweeten(xs[0]), unsweetenArray(xs.slice(1)));

const unsweetenComp = x => {
  const x1 = Object.create(Object.getPrototypeOf(x));
  for (let k of keysIn(x)) {
    x1[k] = unsweeten(x[k]);
  }
  return x1;
};

const sweeten = x => {
  if (x === NIL) return [];
  else if (isPair(x)) return sweetenPair(x);
  else if (isComp(x)) return sweetenComp(x);
  else return x;
};

const isPair = x => x && typeof x === 'object' && FIRST in x && REST in x;

const sweetenPair = p => {
  const f = sweeten(first(p)), r = sweeten(rest(p));
  return Array.isArray(r) ? [f, ...r] : cons$1(f, r);
};

const sweetenComp = x => {
  const x1 = Object.create(Object.getPrototypeOf(x));
  for (let k of keysIn(x)) {
    x1[k] = sweeten(x[k]);
  }
  return x1;
};

const unify = (x, y, s) => {
  x = walk(x, s), y = walk(y, s);
  if (x === y) return s;
  else if (isVar(x)) return extendS(x, y, s);
  else if (isVar(y)) return extendS(y, x, s);
  else if (isComp(x) && isComp(y)) return unifyComp(x, y, s);
  else return false;
};

const unifyComp = (x, y, s) =>
  keysIn(y).every(k => k in x)
  &&
  keysIn(x).reduce((s, k) => s && k in y && unify(x[k], y[k], s), s);

const extendS = (v, x, s) => !occursIn(v, x, s) && new Map(s).set(v, x);

const occursIn = (v, x, s) => {
  x = walk(x, s);
  if (v === x) return true;
  else if (isComp(x)) return keysIn(x).some(k => occursIn(v, x[k], s));
  else return false;
};

// Primitive Goals
const succeedo = s => unit(s);
const failo = _ => empty;

const eq = (a, b) => s => {
  s = unify(unsweeten(a), unsweeten(b), s);
  return s ? unit(s) : empty;
};

// Goal Constructors
const conde = (...gs) => disj(gs.map(expand));

const exist = goalF => {
  const vars = iota(goalF.length).map(Var);
  return expand(goalF(...vars));
};

const disj = gs => gs.reduce(disj2, failo);
const disj2 = (g1, g2) => s => concat(g1(s), g2(s));

const conj = gs => gs.reduce(conj2, succeedo);
const conj2 = (g1, g2) => s => chain(g2, g1(s));

const expand = body => conj(toArray(body));

const run = (count=false) => goalF => {
  const q = Var();
  const subs = expand(goalF(q, WILD))(new Map());
  return take(count, subs).map(s => reify(q, s)).map(sweeten);
};

const Rel = goalF => (...xs) => s => () => expand(goalF(...xs))(s);

const nilo = Rel(x => eq(x, []));
const conso = Rel((a, d, p) => eq(p, cons$1(a, d)));
const firsto = Rel((p, a) => exist(d => conso(a, d, p)));
const resto = Rel((p, d) => exist(a => conso(a, d, p)));

exports.Rel = Rel;
exports.conde = conde;
exports.cons = cons$1;
exports.conso = conso;
exports.eq = eq;
exports.exist = exist;
exports.failo = failo;
exports.first = first;
exports.firsto = firsto;
exports.nilo = nilo;
exports.rest = rest;
exports.resto = resto;
exports.run = run;
exports.succeedo = succeedo;
