'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var d3 = require('d3-selection');
require('d3-transition');

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/**
 * Work out what element type based on element name
 * Most commonly 'svg' or 'html'
 */
function getNamespace(elementName) {
  // SVG Element list from
  // https://developer.mozilla.org/en-US/docs/Web/SVG/Element
  if ([// 'a',
  'animate', 'animateMotion', 'animateTransform', 'circle', 'clipPath', 'color-profile', 'defs', 'desc', 'discard', 'ellipse', 'feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence', 'filter', 'foreignObject', 'g', 'hatch', 'hatchpath', 'image', 'line', 'linearGradient', 'marker', 'mask', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', // 'script',
  'set', 'solidcolor', 'stop', // 'style',
  'svg', 'switch', 'symbol', 'text', 'textPath', 'title', 'tspan', 'unknown', 'use', 'view'].includes(elementName)) {
    return 'svg';
  }

  return 'html';
}
// From https://developer.mozilla.org/en-US/docs/Web/HTML/Element
// const htmlElements = [
//   // Document Metadata
//   'html',
//   'base',
//   'head',
//   'link',
//   'meta',
//   'style',
//   'title',
//   // Sectioning Root
//   'body',
//   // Content Sectioning
//   'address',
//   'article',
//   'aside',
//   'footer',
//   'header',
//   'h1',
//   'h2',
//   'h3',
//   'h4',
//   'h5',
//   'h6',
//   'hgroup',
//   'main',
//   'nav',
//   'section',
//   // Text Content
//   'blockquote',
//   'dd',
//   'div',
//   'dl',
//   'figcaption',
//   'figure',
//   'hr',
//   'li',
//   'main',
//   'ol',
//   'p',
//   'pre',
//   'ul',
//   // Inline Text Semantics
//   'a',
//   'abbr',
//   'b',
//   'bdi',
//   'bdo',
//   'br',
//   'cite',
//   'code',
//   'data',
//   'dfn',
//   'em',
//   'i',
//   'kbd',
//   'mark',
//   'q',
//   'rb',
//   'rp',
//   'rt',
//   'rtc',
//   'ruby',
//   's',
//   'samp',
//   'small',
//   'span',
//   'strong',
//   'sub',
//   'sup',
//   'time',
//   'u',
//   'var',
//   'wbr',
//   // Image and Multimedia
//   'area',
//   'audio',
//   'img',
//   'map',
//   'track',
//   'video',
//   'embed',
//   'iframe',
//   'object',
//   'param',
//   'picture',
//   'source',
//   // Scripting
//   'canvas',
//   'noscript',
//   'script',
//   // Demarcating Edits
//   'del',
//   'ins',
//   // Table Content
//   'caption',
//   'col',
//   'colgroup',
//   'table',
//   'tbody',
//   'td',
//   'tfoot',
//   'th',
//   'thead',
//   'tr',
//   // Forms
//   'button',
//   'datalist',
//   'fieldset',
//   'form',
//   'input',
//   'label',
//   'legend',
//   'meter',
//   'optgroup',
//   'option',
//   'output',
//   'progress',
//   'select',
//   'textarea',
//   // Interactive Elements
//   'details',
//   'dialog',
//   'menu',
//   'summary',
//   // Web Components
//   'slot',
//   'template',
// ];

// TODO: Consider incorporating element types from:
// https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react/index.d.ts

/**
 * Using D3, this function renders elements based on declarative `data`, effectively replacing `select`, `append`, `data`, `join`, `enter`, `exit`, `transition` and more.
 * @param selector
 * @param data
 */

function render(selector, data) {
  // Crude way to check if `selector` is a D3 selection
  if (typeof selector === 'object' && selector._groups && selector._parents) {
    return renderSelection(selector, data);
  }

  var selection = d3.select(selector);
  return renderSelection(selection, data);
}
/**
 * Recursively renders elements based on `data`, which can be deeply nested with the `children` key.
 */

function renderSelection(selection, data, level) {

  if (!Boolean(data)) {
    return selection;
  }

  return selection // Cool way to select immediate children. (Totally didn't know you could do this)
  .selectAll(function (_, i, nodes) {
    return nodes[i].children;
  }).data( // Ensure all data elements are okay
  data.filter(function (d) {
    return Boolean(d);
  }), function (d, i) {
    return (d === null || d === void 0 ? void 0 : d.key) || i;
  }).join(function (enter) {
    return enter.append(function (d) {
      // Yes you saw that right. Append element based on 'append' key in data.
      // Makes this whole function incredibly flexible
      var namespace = getNamespace(d.append);

      if (namespace === 'html') {
        return document.createElement(d.append);
      } // https://stackoverflow.com/questions/51857699/append-shapes-dynamically-in-d3


      return document.createElementNS( // @ts-ignore
      d3.namespace(namespace).space, d.append);
    }).each(function (d) {
      var element = d3.select(this); // Hook into things like selection.call(xAxis)

      if (typeof d.call === 'function') {
        d.call(element);
      } // Add initial attributes. For now, initial and exit values are the same


      element.call(function (selection) {
        return addAttributes(selection, d, 'start');
      }); // Add HTML

      if (d.html) {
        element.html(d.html);
      } // Add events to element eg. onClick


      element.call(function (selection) {
        return addEvents(selection, d);
      }); // Add enter transitions

      element.call(function (selection) {
        return addTransition(selection, d, 'enter');
      }); // element.call(selection =>
      //   addEvents(selection, d, 'onTransition')
      // );
      // Recursively run again, passing in each child in selection

      renderSelection(element, d.children);
    });
  }, function (update) {
    return update.each(function (d) {
      var element = d3.select(this);
      element.call(function (selection) {
        return addTransition(selection, d, 'update');
      });
      renderSelection(element, d.children);
    });
  }, function (exit) {
    // Important magic sauce to exit all descendent children
    exit.selectAll('*').each(exitTransition); // NOTE: This doesn't seem to work, but '*' above will do for now
    // exit.each(function(d) {
    //   renderSelection(d3.select(this), d, level + 1);
    // });

    return exit.each(exitTransition);
  });
}
/**
 * Add attributes to element node
 * @param selection
 * @param datum
 * @param state
 */

function addAttributes(selection, datum, state // node = null
) {
  // Assume anything other than key, text etc are attributes
  var attributes = _objectWithoutPropertiesLoose(datum, ["append", "call", "key", "text", "html", "style", "children", "duration", "delay", "ease"]); // Rather than hand coding every attribute, we loop over the attributes object


  for (var _key in attributes) {
    var attributeValue = attributes[_key];
    var value = getValue(attributeValue, state);
    var isEvent = _key.indexOf('on') === 0; // Skip any on* events, we'll handle them in addEvents

    if (!isEvent) {
      selection.attr(keyToAttribute(_key), value);
    }
  }

  if (datum.text) {
    selection.text(datum.text);
  }

  if (datum.style) {
    selection = addStyles(selection, datum.style, state);
  }

  return selection;
}
/**
 * Add event to selection element
 * @param selection
 * @param datum
 */


function addEvents(selection, datum, onPrefix) {
  if (onPrefix === void 0) {
    onPrefix = 'on';
  }

  // Loop throught all keys in datum
  for (var key in datum) {
    var isEvent = key.indexOf(onPrefix) === 0; // Only allow keys with on*

    if (isEvent) {
      (function () {
        var callback = datum[key]; // Check that the value is a callback function

        if (typeof callback === 'function') {
          var eventName = key.replace(onPrefix, '').toLowerCase();
          selection.on(eventName, function (e, d) {
            return callback(e, d);
          });
        }
      })();
    }
  }

  return selection;
}
/**
 * Adds inline styles to the element
 * @param selection
 * @param styles
 * @param state
 */


function addStyles(selection, styles, state) {
  for (var key in styles) {
    var styleValue = styles[key];
    var value = getValue(styleValue, state);
    selection.style(camelToKebab(key), value);
  }

  return selection;
}
/**
 * Add transition to element, animating to a particular `state` by updating
 * selection with `addAttributes`
 * @param selection
 * @param datum
 * @param state
 */


function addTransition(selection, datum, state) {
  if (state === void 0) {
    state = 'enter';
  }

  var duration = getValue(datum.duration, state);

  if (!Boolean(datum)) {
    return selection;
  }

  var delay = getValue(datum.delay, state) || 0;
  var ease = getValue(datum.ease, state);
  var transition = selection.transition().delay(delay).duration(duration);

  if (typeof ease === 'function') {
    transition = transition.ease(function (t) {
      return ease(t);
    });
  }

  if (state === 'exit') {
    transition = transition.remove();
  }

  return selection.transition(transition).call(function (selection) {
    return addAttributes(selection, datum, state);
  });
}

function exitTransition(d) {
  d3.select(this).call(function (selection) {
    return addTransition(selection, d, 'exit');
  });
}
/**
 * Get value from ElementDatum key, process and pass to selection.attr(),
 * selection.transition() or selection.style()
 * Every value can have an optional exit/enter value
 * We just check if value is an object eg. { exit: 0, enter: 100 }
 * @param value
 * @param state
 */


function getValue(value, state) {
  if (typeof value === 'object') {
    var newValue = value[state]; // Default to `exit` if `start` value not available
    // Assume that element will start the same way it exits

    if (state === 'start' && isEmpty(newValue)) {
      return value['exit'];
    } // Default to `enter` if `update` value not available


    if (state === 'update' && isEmpty(newValue)) {
      return value['enter'];
    }

    return newValue;
  }

  return value;
}
/**
 * Convert camelCase to kebab-case for JavaScript to HTML/CSS interop
 * @param string
 */


function camelToKebab(string) {
  return string.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase();
}
/**
 * Convert key to HTML attribute. Most keys will change from camel to kebab
 * case, except for certain SVG attributes.
 * @param string
 */


function keyToAttribute(key) {
  if (['allowReorder', 'attributeName', 'attributeType', 'autoReverse', 'baseFrequency', 'baseProfile', 'calcMode', 'clipPathUnits', 'contentScriptType', 'contentStyleType', 'diffuseConstant', 'edgeMode', 'externalResourceRequired', 'filterRes', 'filterUnits', 'glyphRef', 'gradientTransform', 'gradientUnits', 'kernelMatrix', 'kernelUnitLength', 'keyPoints', 'keySplines', 'keyTimes', 'lengthAdjust', 'limitingConeAngle', 'markerHeight', 'markerUnits', 'markerWidth', 'maskContentUnits', 'maskUnits', 'numOctaves', 'pathLength', 'patternContentUnits', 'patternTransform', 'patternUnits', 'pointsAtX', 'pointsAtY', 'pointsAtZ', 'preserveAlpha', 'preserveAspectRatio', 'primitiveUnits', 'referrerPolicy', 'refX', 'refY', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'specularConstant', 'specularExponent', 'spreadMethod', 'startOffset', 'stdDeviation', 'stitchTiles', 'surfaceScale', 'systemLanguage', 'tableValues', 'targetX', 'targetY', 'textLength', 'viewBox', 'xChannelSelector', 'yChannelSelector', 'zoomAndPan'].includes(key)) {
    return key;
  }

  return camelToKebab(key);
}

function isEmpty(value) {
  return value == null;
}

function chainedRender(data) {
  return render(this, data);
}

d3.selection.prototype.render = chainedRender;

exports.default = render;
exports.renderSelection = renderSelection;
//# sourceMappingURL=d3-render.cjs.development.js.map
